### 题目分析
**问题描述**：  
给定 `n` 个气球，每个气球对应一个数字 `nums[i]`。戳破第 `i` 个气球可以获得 `nums[i-1] * nums[i] * nums[i+1]` 枚硬币，若 `i-1` 或 `i+1` 越界，则视为数字 `1`。求戳破所有气球能获得的最大硬币数量。

**关键观察**：
1. **后效性问题**：戳破一个气球会影响相邻气球的关系，导致后续选择依赖前面的操作。所以这里动态规划直接用dp[i]是不可行的，至少是dp[i][j]的形式
2. **逆向思维**：如果最后一个戳破的气球是 `k`，则此时其左右边界是固定的（因为其他气球已被戳破），这为动态规划提供了突破口。

---

### 动态规划思路
#### 1. 状态定义
定义 `dp[i][j]` 表示在 **开区间** `(i, j)` 内戳破所有气球能获得的最大硬币数。
- **开区间**：不包含 `i` 和 `j`，因此 `i` 和 `j` 始终作为边界存在，不会被戳破。
- **目标**：最终求 `dp[0][n+1]`，即在原数组两侧虚拟添加 `1` 后的开区间 `(0, n+1)` 的最大值。

#### 2. 状态转移
在开区间 `(i, j)` 中，假设最后一个戳破的是气球 `k`（`i < k < j`）：
- **戳破 `k` 的收益**：`nums[i] * nums[k] * nums[j]`（因为此时 `i` 和 `j` 是边界）。
- **子问题分解**：
    - 左侧区间 `(i, k)` 的最大收益为 `dp[i][k]`。
    - 右侧区间 `(k, j)` 的最大收益为 `dp[k][j]`。
- **状态转移方程**：
  ```plaintext
  dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j] + nums[i] * nums[k] * nums[j])